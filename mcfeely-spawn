#!/usr/bin/perl
# vi:sw=4:ts=4:wm=0:ai:sm:et

# mcfeely        Asynchronous remote task execution.
# Copyright (C) 1999 Kiva Networking
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
# You may contact the maintainer at <mcfeely-maintainer@systhug.com>.

use strict;

use McFeely::Internal;
use POSIX;
use IO::Select;
use IO::Handle;
use IO::Pipe;
use Fcntl;
use Symbol;

require 'chdir.pl';

# get the file descriptors off the command line
my $in  = shift;
my $out = shift;
my $sir = new IO::Handle; # sir was STDIN
my $srw = new IO::Handle; # srw was STDOUT
$sir->fdopen($in, "r")  or die "open SIR (fd $in) failed: $!\n";
$srw->fdopen($out, "w") or die "open SRW (fd $out) failed: $!\n";


# these hashes contain per task information
# about filehandles, slots, the status of the fork
# and any message that might be involved
my %Fh;
my %Slot;
my %Stat;
my %Msg;

# the pipe on which we write to our children
my $write_pipe;

$| = 1;

# change directories to the top of the mcfeely tree so we 
# can have reasonable access to the queue
chdir_top() or bail("cannot chdir: $!");

# we need to establish the reaper as being there for our later
# use when our children die
$SIG{CHLD} = \&reaper;

# the subroutine in which we read the information and fork 
# out the mcfeely-ttpc
doit(\&launch_ttpc, \&pack_result);
hard(0, "doit returned! $!");
# we're done
exit;

#### begin the subs, all the real action happens below

sub soft {
    my $slot   = shift;
    my $status = 99;
    
    hardsoft_error($slot, $status, @_);
}

sub hard {
    my $slot   = shift;
    my $status = 100;
    
    hardsoft_error($slot, $status, @_);
}

sub hardsoft_error { 
    my $slot   = shift;
    my $status = shift;
    my $msg    = join('', @_);

    # Tack an end-of-transmission at the end of msg.
    $msg .= "\0";
    $msg .= pack 'c', 0x4;

    $srw->print("$slot\0$status\0$msg");
    exit $status;
}

# fork off mcfeely-ttpc
sub launch_ttpc {
    my $ino = shift;
    chomp $ino;
    my $pid;

    if (!defined ( $pid = fork() )) {
        # There was an error.
        return($ino, undef);
    } elsif ($pid == 0) {
        # I am the child.
        unless(open STDIN, "queue/task/$ino") {
            print STDOUT "trouble opening queue/task/$ino: $!";
            exit 100;
        }
            #or soft $ino, "trouble opening queue/task/$ino: $!";
        #open(STDOUT, ">&main::WP')
        # getting this next bit to work for some reason 
        # requires the fileno, not the handle don't know why
        my $write_pipe_no = $write_pipe->fileno();
        unless(open(STDOUT, ">& $write_pipe_no")) {
            print STDOUT "trouble duping STDOUT: $!";
            exit 99;
        }
            #or soft $ino, "trouble duping STDOUT: $!";
        close STDERR;
        #open(STDERR, '>&main::WP')
        #    or soft "trouble duping STDERR: $!";

        # start our client with the task number identifier
        unless (exec 'bin/mcfeely-ttpc', $ino) {
            print STDOUT "Couldn't exec tcpclient: $!";
            exit 99;
        }
    } else {
        # I am the parent.
        # close WP, my child is going to write on it not me.
        #close main::WP;
        $write_pipe->close();
        return($ino, $pid);
    }
}

# take the results from the mcfeely-ttpc and pass them pack up 
sub pack_result {
    my %args = @_;

    # tack a \0 on the end of message so we can have multi
    # line reports
    $args{msg} .= "\0";
    # Tack an end-of-transmission at the end of msg.
    $args{msg} .= pack 'c', 0x4;

    return("$args{slot}\0$args{status}\0$args{msg}");
}

sub doit {
    # reference to the subroutine that is called when
    # we want to fork
    my $fork_sub = shift;
    # reference to the subrouting that is called that
    # reads the results from the child
    my $pack_sub = shift;

    my $buf;
    my $line;
    my $ok;
    my $pid;
    my $oldsigset;
    my $sig_chld_set;
    my $slot;
    my @ready_to_read;

    $srw->autoflush(1);

    # let the forthcoming select loop know that it is STDIN (sort of)
    # that we'll be waiting on
    my $select = new IO::Select();
    $select->add($sir);

    $sig_chld_set = POSIX::SigSet->new(&POSIX::SIGCHLD);
    $oldsigset = POSIX::SigSet->new;

    # loop
    while (1) {
        my $stage;
        my @lines;
        # may need to do some tricks with blocking here

        # wait for some data or a signal
        $sir->blocking(1);
        @ready_to_read = $select->can_read(10); #XXX

        # read instructions
        $sir->blocking(0);
        $stage .= $buf
            while (defined($ok = sysread $sir, $buf, 1024)
                and $ok > 0);
        return unless $! == POSIX::EWOULDBLOCK;

        # load lines
        if (defined $stage) {
            push @lines, $& while $stage =~ s/^.*\n//;
        }

        # follow instructions
        while ($line = shift @lines) {

            # create the pipe that we will talk to kids with
            my $read_pipe  = new IO::Handle;
            $write_pipe = new IO::Handle;
            my $pipe1   = new IO::Pipe($read_pipe, $write_pipe);
            if (!defined($pipe1)) {
                soft 0, "unable to creat pipe: $!";
            }

            # keep track of children
            sigprocmask(&POSIX::SIG_BLOCK, $sig_chld_set, $oldsigset);

            # and call the fork_sub
            ($slot, $pid) = &$fork_sub($line);

            # if $pid is undef then for some reason we could
            # not fork and if that's the case we need to let
            # the other know that badness is afoot and they
            # should try later
            if (!defined($pid)) {
                soft $slot, "unable to fork: $!";
            }

            # save away the informatin about the task based
            # used the pid as the key
            $Slot{$pid} = $slot;
            $Fh{$pid} = $read_pipe;

            # continue keeping hold of children
            sigprocmask(&POSIX::SIG_UNBLOCK, $sig_chld_set, $oldsigset);
        }

        # dig the results
        PID: foreach $pid (keys %Stat) {
            $srw->print(&$pack_sub(slot => $Slot{$pid},
                                  status => $Stat{$pid},
                                  msg => $Msg{$pid}));
            delete $Slot{$pid};
            delete $Stat{$pid};
            delete $Msg{$pid};
        }

    }
}

sub reaper {
    my $baby;
    my $fh;
    my $read_count;

    while (($baby = waitpid(-1, &WNOHANG)) > 0) {
        my $buf;
        $fh = $Fh{$baby}; # XXX: Oi!
        $Stat{$baby} = ($? >> 8);
        $fh->blocking(1);
        $read_count = $fh->read($buf, 1024);
        if (!defined($read_count)) {
            delete $Fh{$baby};
            $fh->close();
            hard($baby, "bad read from ttpc: $!");
        } elsif ($read_count == 0) {
            delete $Fh{$baby};
            $fh->close();
            hard($baby, "EOF on read from ttpc");
        } else {
            $Msg{$baby} = "$buf";
            delete $Fh{$baby};
            $fh->close();
        }
    }
}

sub END {
    open OUT, ">/tmp/mcfeely-spawn.$$";
    print OUT "I've died\n";
    print OUT "my latest bang: $!\n";
    close OUT;
}
    
